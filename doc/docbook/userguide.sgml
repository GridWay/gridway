<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<book lang="en">
<bookinfo>
  <title>GridWay 5.2 Documentation: User Guide</title>
  <pubdate>February, 2007</pubdate>
  <copyright>
    <year>2002-2007</year>
    <holder>GridWay Team, Distributed Systems Architecture Group, Universidad
    Complutense de Madrid.</holder>
  </copyright>
  <legalnotice>
    <para>
    Licensed under the Apache License, Version 2.0 (the "License"); you may not
    use this file except in compliance with the License. You may obtain a copy
    of the License at
    </para>
    <para>
    <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</ulink>
    </para>
    <para>
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
    License for the specific language governing permissions and limitations
    under the License.
    </para>
    <para>
    Any academic report, publication, or other academic disclosure of results
    obtained with the GridWay Metascheduler will acknowledge GridWay's use by an
    appropriate citation to relevant papers by GridWay team members.
    </para>
  </legalnotice>
</bookinfo>

<chapter>
<title>Introduction to the GridWay Metascheduler</title>

  <sect1>
  <title>Benefits for the end user </title>

  <para>
  GridWay, on top of Globus services, enables large-scale, secure and reliable
  sharing of computing resources (clusters, computing farms, servers,
  supercomputers...), managed by different resource management systems (PBS,
  SGE, LSF, Condor...), within a single organization (enterprise grid) or
  scattered across several administrative domains (partner or supply-chain
  grid). GridWay provides the end-user with a working environment and
  functionality similar to those found on local DRM systems, such as SGE, LSF or
  PBS. The end-user is able to submit, monitor and control his jobs by means of
  DRM-like commands (<command>gwsubmit</command>, <command>gwwait</command>,
  <command>gwkill</command>, <command>gwhosts</command>...) or the DRMAA API. In
  particular:
  </para>

  <para>
  <itemizedlist>
    <listitem>
    <para>
    Reliable and unattended execution of jobs: Transparently to the end user,
    the scheduler is able to manage the different failure situations.
    </para>
    </listitem>

    <listitem>
    <para>
    Efficient execution of jobs: Jobs are executed on the faster available
    resources.
    </para>
    </listitem>

    <listitem>
    <para>
    Broad application scope: GridWay is not bounded to a specific class of
    application generated by a given programming environment and does not
    require application deployment on remote hosts, which extends its
    application range and allows reusing of existing software. GridWay allows
    submission of single, array or complex jobs consisting of task dependencies,
    which may require file transferring and/or database access.
    </para>
    </listitem>

    <listitem>
    <para>
    DRM Command Line Interface: The GridWay command line interface is similar to
    that found on Unix and resource management systems such as PBS or SGE. It
    allows users to submit, kill, migrate, monitor and synchronize jobs.
    Moreover, jobs can be specified in GridWay Job Template format or using the
    JSDL (Job Submission Description Language) OGF standard.
    </para>
    </listitem>

    <listitem>
    <para>
    DRMAA Application Programming Interface: GridWay provides full support for
    DRMAA (GGF standard) to develop distributed applications (C and
    JAVA bindings).
    </para>
    </listitem>
  </itemizedlist>
  </para>
  </sect1>

  <sect1>
  <title>How GridWay operates</title>

  <para>
  GridWay enables you to treat your jobs as if they were Unix processes. Each
  job is given a numerical identifier, analogous to the PID of a process. This
  value is called the Job identifier, JID for short. If the job belongs to an
  array job, it will also have an array identifier, AID for short. A job index
  within an array is called the task identifier, TID for short.
  </para>

  <para>
  Jobs are submitted using the <command>gwsubmit</command> command. A job is
  described by its template file. Here you can specify the job's executable
  file, its command line arguments, input/output files, standard stream
  redirection as well as other aspects.
  </para>

  <para>
  Jobs can be monitored using the <command>gwps</command> command. You can
  control your jobs at runtime using the <command>gwkill</command> command. You
  can synchronize your jobs using the <command>gwwait</command> command. You can
  find out what resources your job has used with the
  <command>gwhistory</command> command.
  </para>

  <para>
  System monitoring commands allow you to gather information of the GridWay
  system and the Grids you are using. These commands are:
  <command>gwuser</command> to show information about the users using GridWay;
  <command>gwhost</command> to monitor the  available hosts in the testbed; and
  <command>gwacct</command> to print usage (accounting) information per user or
  host.
  </para>

  <note>
  <para>
  Every command has a <option>-h</option> option which shows its usage and
  available options.
  </para>
  </note>
  </sect1>

  <sect1>
  <title>Job life-cycle in GridWay</title>

  <para>
  A job can be in one of the following dispatch states (DM state):
  <itemizedlist>
    <listitem>
    <para>
    Pending (<computeroutput>pend</computeroutput>): The job is waiting for a
    resource to run on. The job reaches this state when it is initially
    submitted by the user or when it is restarted after a failure, stop or
    self-migration.
    </para>
    </listitem>

    <listitem>
    <para>
    Hold (<computeroutput>hold</computeroutput>): The owner (or GridWay
    administrator) has held the job. It will not be scheduled until it receives
    a release signal.
    </para>
    </listitem>

    <listitem>
    <para>
    Prolog (<computeroutput>prol</computeroutput>): The job is preparing the
    remote system, by creating the execution directory in the remote host and
    transferring the input and restart (in case of migration) files to it.
    </para>
    </listitem>

    <listitem>
    <para>
    Pre-wrapper (<computeroutput>prew</computeroutput>): The job is making some
    advanced preparation tasks in the remote resource, like getting some data
    from a service, obtaining software licenses, etc.
    </para>
    </listitem>

    <listitem>
    <para>
    Wrapper (<computeroutput>wrap</computeroutput>): The job is executing the
    Wrapper, which in turns executes the actual application. It also starts a
    self-monitoring program if specified. This monitor, watches the raw
    performance (CPU usage) obtained by the application.
    </para>
    </listitem>

    <listitem>
    <para>
    Epilog (<computeroutput>epil</computeroutput>): The job is finalizing. In
    this phase it transfers the output and restart (in case of failure, stop or
    self-migration) files and cleaning up the remote system directory.
    </para>
    </listitem>

    <listitem>
    <para>
    Migration (<computeroutput>migr</computeroutput>): The job is migrating from
    one resource to another, by cancelling the execution of Wrapper and
    performing finalization tasks in the old resource (like in Epilog state) and
    preparation tasks in the new resource (like in Prolog state).
    </para>
    </listitem>

    <listitem>
    <para>
    Stopped (<computeroutput>stop</computeroutput>): The job is stopped. If
    restart files have been defined in the Job Template, they are transferred
    back to the client, and will be used when the job is resumed.
    </para>
    </listitem>

    <listitem>
    <para>
    Failed (<computeroutput>fail</computeroutput>): The job failed.
    </para>
    </listitem>

    <listitem>
    <para>
    Done (<computeroutput>done</computeroutput>): The job is done and the user
    can check the exit status.
    </para>
    </listitem>
    </itemizedlist>
  </para>

  <figure>
    <title>Simplified state machine of the GridWay Metascheduler.</title>
    <graphic align="center" fileref="../images/gw_states.jpg">
  </figure>

  <para>
  When a job is in Wrapper dispatch state, it can be in one of the following
  execution states (EM state), which are a subset of the available Globus GRAM
  states:
  <itemizedlist>

    <listitem>
    <para>
    Pending (<computeroutput>pend</computeroutput>): The job has been
    successfully submitted to the local DRM system and it is waiting for the
    local DRM system to execute it.
    </para>
    </listitem>

    <listitem>
    <para>
    Suspended (<computeroutput>susp</computeroutput>): The job has been
    suspended by the local DRM system.
    </para>
    </listitem>

    <listitem>
    <para>
    Active (<computeroutput>actv</computeroutput>): The job is being executed by
    the local DRM system
    </para>
    </listitem>

    <listitem>
    <para>
    Failed (<computeroutput>fail</computeroutput>): The job failed.
    </para>
    </listitem>

    <listitem>
    <para>
    Done (<computeroutput>done</computeroutput>): The job is done.
    </para>
    </listitem>

  </itemizedlist>
  </para>

  <para>
  Finally, The following flags are associated with a job (RWS flags):
  <itemizedlist>

    <listitem>
    <para>
    Restarted (<computeroutput>R</computeroutput>): Number of times the job was
    restarted or migrated.
    </para>
    </listitem>

    <listitem>
    <para>
    Waiting (<computeroutput>W</computeroutput>): Number of clients waiting for
    this job to end.
    </para>
    </listitem>

    <listitem>
    <para>
    Rescheduled (<computeroutput>S</computeroutput>): 1 if this job is waiting
    to be rescheduled, 0 otherwise.
    </para>
    </listitem>
  </itemizedlist>
  </para>
  </sect1>

  <sect1>
  <title>A grid-aware application model</title>

  <para>
  In order to obtain a reasonable degree of both application performance and
  fault tolerance, a job must be able to adapt itself according to the
  availability of the resources and the current performance provided by them.
  Therefore, the classical application model must be extended to achieve
  such functionality.
  </para>

  <para>
  The GridWay system assumes the following application model:
  <itemizedlist>

    <listitem>
    <para>
    <emphasis>Executable</emphasis>: The executable must be compiled for the
    remote host architecture. GridWay provides a straightforward method to
    select the appropriate executable for each host. The variable
    <varname>GW_ARCH</varname>, as provided by the Information MAD, can be used
    to define the executable in the Job Template (for example,
    EXECUTABLE=sim_code.${GW_ARCH})
    </para>
    </listitem>

    <listitem>
    <para>
    <emphasis>Input files</emphasis>: These files are staged to the remote host.
    GridWay provides a flexible way to specify input files and supports
    Parameter Sweep like definitions. Please note that these files may be also
    architecture dependent.
    </para>
    </listitem>

    <listitem>
    <para>
    <emphasis>Output files</emphasis>: These files are generated on the remote
    host and transferred back to the client once the job has finished.
    </para>
    </listitem>

    <listitem>
    <para>
    <emphasis>Standard streams</emphasis>: The standard input (STDIN) file is
    transferred to the remote system previous to job execution. Standard output
    (STDOUT) and standard error (STDERR) streams are also available at the
    client once the job has finished. These files could be extremely useful for
    debugging.
    </para>
    </listitem>

    <listitem>
    <para>
    <emphasis>Restart files</emphasis>: Restart files are highly advisable if
    dynamic scheduling is performed. User-level checkpointing managed by the
    programmer must be implemented because system-level checkpointing is not
    possible among heterogeneous resources.
    </para>
    </listitem>
  </itemizedlist>
  </para>

  <para>
  Migration is commonly implemented by restarting the job on the new candidate
  host. Therefore, the job should generate restart files at regular intervals in
  order to restart execution from a given point. However, for some application
  domains the cost of generating and transferring restart files could be greater
  than the saving in compute time due to checkpointing. Hence, if the
  checkpointing files are not provided the job is restarted from the beginning.
  In order not to reduce the number of candidate hosts where a job can migrate,
  the restart files should be architecture independent.
  </para>
  </sect1>
</chapter>

<chapter id='UserEnvConf'>
<title>User environment configuration</title>

  <important>
  <para>
    You should include the following environment variables in your shell
    configuration file. (example <filename>$HOME/.bashrc</filename>)
  </para>
  </important>

  <para>
  In order to set the user environment, follow these steps:
  <orderedlist>

    <listitem>
    <para>
    Set up Globus user environment:
    <screen>$ source $GLOBUS_LOCATION/etc/globus-user-env.sh</screen>
    </para>
    <para>
    or
    <screen>$ . $GLOBUS_LOCATION/etc/globus-user-env.csh</screen>
    </para>
    <para>
    depending on the shell you are using.
    </para>
    </listitem>

    <listitem>
    <para>
    Set up the GridWay user environment:
    <screen>
$ export GW_LOCATION=&lt;path_to_GridWay_installation>
$ export PATH=$PATH:$GW_LOCATION/bin</screen>
    </para>
    <para>
    or
    <screen>
$ setenv GW_LOCATION &lt;path_to_GW_location>
$ setenv PATH $PATH:$GW_LOCATION/bin</screen>
    </para>
    <para>
    depending on the shell you are using.
    </para>
    </listitem>

    <listitem>
    <para>
    Optionally, you can set up your environment to use the GridWay
    DRMAA library:
    <screen>
$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$GW_LOCATION/lib</screen>
    </para>
    <para>
    or: <screen>
$ setenv LD_LIBRARY_PATH $LD_LIBRARY_PATH:$GW_LOCATION/lib</screen>
    </para>
    </listitem>

    <listitem>
    <para>
    Finally, if GridWay has been compiled with accounting support, you may need
    to set up the DB library. For example, if DB library has been installed in
    <filename>/usr/local/BerkeleyDB.4.4</filename>:
    <screen>$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/BerkeleyDB.4.4/lib</screen>
    </para>
    <note>
    <para>
    This step is only needed if your environment has not been configured, ask
    your administrator.
    </para>
    </note>
    </listitem>
  </orderedlist>
  </para>
</chapter>

<chapter>
  <title>Job definition</title>

  <sect1>
  <title>Job description overview</title>

  <para>
  Job Templates allow you to configure your job requirements, in terms of
  needed files, generated files, requirements and ranks of execution hosts, as
  well as other options.
  </para>

  <para>
  Syntax:
  <screen>
&lt;VARIABLE> = ["]&lt;VALUE>["]
# &lt;Comments></screen>
  </para>

  <important>
  <para>
    Default values for EVERY Job Template are read from
    <filename>$GW_LOCATION/etc/job_template.default</filename>.
  </para>
  </important>
  </sect1>

  <sect1>
  <title>Job Template options</title>

  <table frame='all'>
	<title>Job Template options.</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <colspec colname='c1' colwidth='6cm'>
    <colspec colname='c2'>
    <tbody>
      <row>
      <entry namest="c1" nameend="c2">General</entry>
      </row>

      <row>
      <entry>NAME</entry>
      <entry>Name of the job (filename of the Job Template by default).</entry>
      </row>
      <row>
      <entry namest="c1" nameend="c2">Execution</entry>
      </row>

      <row>
      <entry>EXECUTABLE</entry>
      <entry>The executable file. Example: EXECUTABLE = bin.${ARCH}</entry>
      </row>

      <row>
      <entry>ARGUMENTS</entry>
      <entry>Arguments to the above executable. Example:
      ARGUMENTS = "${TASK_ID}"</entry>
      </row>

      <row>
      <entry>ENVIRONMENT</entry>
      <entry>User defined, comma-separated, environment variables. Example:
      ENVIRONMENT = SCRATCH_DIR /tmp, LD_LIBRARY_PATH=/usr/local/lib</entry>
      </row>

      <row>
      <entry>TYPE</entry>
      <entry>Type of job. Possible values are "single" (default), "multiple" and
      "mpi", with similar behaviour to that of GRAM jobs.</entry>
      </row>

      <row>
      <entry>NP</entry>
      <entry>Number of processors in MPI jobs. For "multiple" and "single" jobs
      it defines the "count" parameter in the RSL.</entry>
      </row>

      <row>
      <entry namest="c1" nameend="c2">I/O files</entry>
      </row>

      <row>
      <entry>INPUT_FILES</entry>
      <entry>A comma-separated pair of "local remote" filenames. If the remote
      filename is missing, the local filename will be preserved in the
      execution host. Example: INPUT_FILES = param.${TASK_ID} param,
      inputfile</entry>
      </row>

      <row>
      <entry>OUTPUT_FILES</entry>
      <entry>A comma-separated pair of remote filename local filename. If the
      local filename is missing, the remote filename will be preserved in the
      client host. Example: OUTPUT_FILES = outputfile, binary
      binary.${ARCH}.${TASK_ID}</entry>
      </row>

      <row>
      <entry namest="c1" nameend="c2">Standard streams</entry>
      </row>

      <row>
      <entry>STDIN_FILE</entry>
      <entry>Standard input file. Example: STDIN_FILE = /dev/null</entry>
      </row>

      <row>
      <entry>STDOUT_FILE</entry>
      <entry>Standard output file. Example: STDOUT_FILE =
      stdout_file.${JOB_ID}</entry>
      </row>

      <row>
      <entry>STDERR_FILE</entry>
      <entry>Standard error file. Example:
      STDERR_FILE = stderr_file.${JOB_ID}</entry>
      </row>

      <row>
      <entry namest="c1" nameend="c2">Checkpointing</entry>
      </row>

      <row>
      <entry>RESTART_FILES</entry>
      <entry>Checkpoint Files. These files are managed by the programmer and
      should be architecture independent (NO URLS HERE, you can use a
      checkpoint server using CHECKPOINT_URL). Example: RESTART_FILES =
      checkpoint</entry>
      </row>

      <row>
      <entry>CHECKPOINT_INTERVAL</entry>
      <entry>How often (seconds) restart files are transferred from the
      execution host to the checkpointing server.</entry>
      </row>

      <row>
      <entry>CHECKPOINT_URL</entry>
      <entry>GridFTP URL to store/access checkpoint files (Default is job
      experiment directory in localhost). Example:
      CHECKPOINT_URL = gsiftp://hydrus.ucm.es/var/checkpoints/</entry>
      </row>

      <row>
      <entry namest="c1" nameend="c2">Resource selection
      (See <xref linkend="ResSelectExpr"> for more information)</entry>
      </row>

      <row>
      <entry>REQUIREMENTS</entry>
      <entry>A Boolean expression evaluated for each available host, if the
      evaluation returns true the host will be considered to submit the job.
      Example: REQUIREMENTS = ARCH = "i686" & CPU_MHZ > 1000;</entry>
      </row>

      <row>
      <entry>RANK</entry>
      <entry>A numerical expression evaluated for each candidate host (those
      for which the requirement expression is true). Those candidates with
      higher ranks are used first to execute your jobs. Example:
      RANK = (CPU_MHZ * 2) + FREE_MEM_MB;</entry>
      </row>

      <row>
      <entry namest="c1" nameend="c2">Scheduling</entry>
      </row>

      <row>
      <entry>RESCHEDULING_INTERVAL</entry>
      <entry>How often GridWay searches the Grid for better resources to run
      this job. (0 = never)</entry>
      </row>

      <row>
      <entry>RESCHEDULING_THRESHOLD</entry>
      <entry>If a better resource is found and the job has been running less
      than this threshold (in (seconds), it will migrate to the new
      host.</entry>
      </row>

      <row>
      <entry>DEADLINE</entry>
      <entry>Deadline (format [[D:]H:]M) to start the job (0 = none).</entry>
      </row>

      <row>
      <entry namest="c1" nameend="c2">Performance</entry>
      </row>

      <row>
      <entry>SUSPENSION_TIMEOUT</entry>
      <entry>Maximum suspension time (seconds) in the local job management
      system. If exceeded the job is migrated to another host.
      (0 = never)</entry>
      </row>

      <row>
      <entry>CPULOAD_THRESHOLD</entry>
      <entry>If the CPU assigned to your job is less than this given
      percentage, the job will be migrated</entry>
      </row>

      <row>
      <entry>MONITOR</entry>
      <entry>Optional program to monitor job performance</entry>
      </row>

      <row>
      <entry namest="c1" nameend="c2">Fault tolerance</entry>
      </row>

      <row>
      <entry>RESCHEDULE_ON_FAILURE</entry>
      <entry>Behavior in case of failure. Possible values are 'yes' or
      'no'</entry>
      </row>

      <row>
      <entry>NUMBER_OF_RETRIES</entry>
      <entry>Number of retries in case of failure. GridWay follows a
      linear backoff strategy for re-trying file transfers and job
      submissions.</entry>
      </row>

      <row>
      <entry namest="c1" nameend="c2">Advanced job execution</entry>
      </row>

      <row>
      <entry>WRAPPER</entry>
      <entry>Script for wrapper. stdout and stderr streams of this program can
      be found in directory <filename>$GW_LOCATION/var/$GW_JOB_ID</filename>
      as files <filename>stdout.wrapper.$GW_RESTARTED</filename> and
      <filename>stderr.wrapper.$GW_RESTARTED</filename></entry>
      </row>

      <row>
      <entry>PRE_WRAPPER</entry>
      <entry>Optional program that is executed before the execution of the job,
      to perform an additional remote setup (e.g. access a web service). This
      job is ALWAYS submitted to the FORK job-manager. stdout and stderr streams
      of this program can be found in directory
      <filename>$GW_LOCATION/var/$GW_JOB_ID</filename> as files
      <filename>stdout.pre_wrapper.$GW_RESTARTED</filename> and
      <filename>stderr.pre_wrapper.$GW_RESTARTED</filename></entry>
      </row>

      <row>
      <entry>PRE_WRAPPER_ARGUMENTS</entry>
      <entry>Arguments to the pre-wrapper program.</entry>
      </row>
    </tbody>
    </tgroup>
  </table>
  </sect1>

  <sect1>
  <title>File definition in Job Templates</title>

  <para>
  Input and output files are in general specified in a comma-separated,
  source/destination pair.
  </para>
  <screen>SRC1 DST1, SRC2 DST2,...</screen>
  <para>
  We next describe the available alternatives and protocols that you can use
  to choose the best staging strategy for your applications.
  </para>

    <sect2>
    <title> Defining input files </title>

    <para>
      Input files (if staged to the remote host) are always placed in the
      remote experiment directory. However you can specify the name used for
      the file in the remote directory with the destination name (DST above).
      This feature is very useful when your executable always expect a fixed
      input filename, and you want to process different input files (as is
      common in parametric computations).
    </para>

    <important>
      <para>
        The destination names for input files MUST be a single name, do not use
        absolute paths or URLs.
      </para>
    </important>

    <para>
    You can specify the input files using:
    <itemizedlist>
      <listitem>
        <para>
        <emphasis>Absolute path</emphasis>: In this case no staging is
        performed. File is assumed to be in that location in the remote host.
        </para>
        <para>
        Example:
<screen>
EXECUTABLE  = /bin/ls      #Will use remote ls!</screen>
        </para>
      </listitem>

      <listitem>
        <para>
        <emphasis>GridFTP URL</emphasis>: The file will be downloaded from the
        given GridFTP url. If no destination is given the filename in the URL
        will be used in the remote host.
        </para>
        <para>
        Example, will copy file <filename>input_exp1</filename> from /tmp in
        machine to the remote host with name <filename>input</filename>.
        <screen>
INPUT_FILES  = gsiftp://machine/tmp/input_exp1 input</screen>
        </para>
      </listitem>

      <listitem>
        <para>
        <emphasis>File URL</emphasis>: The file will copied from an absolute
        path in the local host. If no destination is given the filename in the
        URL will be used in the remote host.
        </para>
        <para>
        Example:
        <screen width='80'>
INPUT_FILES  = file:///etc/passwd #Will copy local /etc/passwd file to remote dir, with name passwd</screen>
        </para>
      </listitem>

      <listitem>
        <para>
        <emphasis>Name</emphasis>: Use simple names to stage files in
        your local experiment directory (directory where the Job Template file
        is placed). If no destination is given the filename will be preserved.
        </para>
        <para>
        Example:
        <screen>
INPUT_FILES  = test_case.bin</screen>
        </para>
      </listitem>
    </itemizedlist>
    </para>
    <note>
    <para>
    The executable is treated as an input file, so the same remarks are
    applicable for the <parameter>EXECUTABLE</parameter> Job Template parameter.
    </para>
    </note>
    </sect2>

    <sect2>
      <title> Defining output files </title>

      <para>
        Output files are always copied FROM the remote experiment directory.
        However you can specify the destination of the output files of your
        applications.
      </para>

      <important>
        <para>
          The source names for output files MUST be a single name, do not use
          absolute paths or URLs.
        </para>
      </important>

      <para>
        You can specify the destination of output files using:
        <itemizedlist>
          <listitem>
            <para>
            <emphasis>Absolute path</emphasis>: The remote file name will be
            copied to the absolute path in the local host. Note that you can
            also use <computeroutput>file:///</computeroutput> protocol.
            </para>
            <para>
            Example, to copy the output file <filename>output.bin</filename>
            in the <filename>/tmp</filename> directory of the local host with name
            <filename>outfile</filename>:
            <screen>
OUTPUT_FILES  = output.bin /tmp/outfile </screen>
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>GridFTP URL</emphasis>: The file will be copied to the
              given GridFTP url.
            </para>
            <para>
              Example, you can also use variable substitution in URLs, see next
              section.
              <screen>
OUTPUT_FILES  = out gsiftp://storage_servere/~/output.${TASK_ID}</screen>
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>Name</emphasis>: Use simple names to stage files to
              your local experiment directory (directory where the Job Template file
              is placed). If no destination is given the filename will be preserved.
            </para>
            <para>
              Example:
              <screen>
OUTPUT_FILES  = test_case.bin</screen>
            </para>
            <para>
              Tip: You can organize your output files in directories in the
              experiment directory (They MUST exist!), using a relative path
            <screen width='80'>
OUTPUT_FILES = outfile Out/file.${JOB_ID} #Directory Out must exist in the experiment directory</screen>
            </para>
          </listitem>
        </itemizedlist>
      </para>
  </sect2>

  <sect2>
      <title> Defining standard streams </title>
      <para>
        Standard streams includes the standard input for your executable
        (<parameter>STDIN_FILE</parameter>) and its standard output and error
        (<parameter>STDOUT_FILE</parameter> and <parameter>STDERR_FILE</parameter>).
      </para>
      <para>
        The STDIN_FILE can be defined using any of the methods described above
        for the input files. However you <emphasis> can not </emphasis> specifed
        a destination name for the standard input stream, as is internally handled
        by the system. Note also that <emphasis> only one</emphasis> standard input
        file can be specified.
      </para>
      <para>
        Example:
        <screen>
STDIN_FILE = In/input.${JOB_ID} #Will use input from directory In</screen>
      </para>
      <para>
        The STDOUT_FILE and STDERR_FILE parameters can be defined
        using any of the methods described above
        for the output files. However you <emphasis> can not </emphasis> specifed
        a source name (only destination).
        Note also that <emphasis> only one</emphasis> standard output and error
        files can be specified.
      </para>
      <para>
        Example:
        <screen>
STDOUT_FILE = Out/ofile #Will place stdout in Out directory with name ofile</screen>
      </para>
    </sect2>

    <sect2>
    <title> Defining restart files </title>

      <para>
        Restart files are periodically copied to the job directory
        (<filename>$GW_LOCATION/var/$JOB_ID/</filename>). Restart files are
        only specified with its name. Note also that you can defined a
        checkpointing server with the <parameter>CHECKPOINT_URL</parameter>
        Job Template parameter.
      </para>
      <para>
        Example:
        <screen>
RESTART_FILES = tmp_file</screen>
      </para>
    </sect2>
  </sect1>

  <sect1 id='VarSub'>
	<title>Variable substitution</title>

  <para>
	You can use variables in the value string of each option, with the format:
  <screen>${GW_VARIABLE}</screen>
	</para>

  <para>
	These variables are substituted at run time with its corresponding value. For example:
	</para>

  <screen>STDOUT_FILE = stdout.${JOB_ID}</screen>

  <para>
	will store the standard output of job 23 in the file <filename>stdout.23</filename>
	</para>

  <para>
	The following table lists the variables available to define job options,
  along with their description.
	</para>

  <table frame='all'>
    <title>Substitution variables.</title>
		<tgroup cols='2' align='left' colsep='1' rowsep='1'>
		<colspec colname='c1' colwidth='6cm'>
		<colspec colname='c2'>
		<tbody>
		  <row>
			<entry>${JOB_ID}</entry>
			<entry>The job identifier</entry>
			</row>

      <row>
			<entry>${ARRAY_ID}</entry>
			<entry>The job array identifier (-1 if the job does not belong to any)</entry>
			</row>

      <row>
			<entry>${TASK_ID}</entry>
			<entry>The task identifier within the job array (-1 if the job does not
      belong to any)</entry>
			</row>

      <row>
			<entry>${TOTAL_TASKS}</entry>
			<entry>The total number of tasks in the job array (-1 if the job does not
      belong to any)</entry>
			</row>

      <row>
			<entry>${ARCH}</entry>
			<entry>The architecture of the selected execution host</entry>
			</row>
       <row>
			<entry>${PARAM}</entry>
			<entry>Allows the assignment of arbitrary start and increment values for array jobs
(start + increment*GW_TASK_ID). Useful to generate file naming patterns or task processing. The values for start and increment
will  be specified with options -s (for start, with 0 by default) and -i (for
increment, with 1 by default) of the gwsubmit command.</entry>
			</row>
       <row>
			<entry>${MAX_PARAM}</entry>
			<entry>Upper bound of the ${PARAM} variable.</entry>
			</row>
	  </tbody>
    </tgroup>
  </table>

  <important>
  <para>
    The above variables can be used in any job option.
  </para>
  </important>
  </sect1>

	<sect1 id="ResSelectExpr">
	<title>Resource selection expressions</title>

    <sect2>
    <title>Requirement expression syntax</title>
    <para>
    The syntax of the requirement expressions is defined as:
    <screen>
stmt::= expr';'
expr::= VARIABLE '=' INTEGER
        | VARIABLE '>' INTEGER
        | VARIABLE '&lt;' INTEGER
        | VARIABLE '=' STRING
        | expr '&' expr
        | expr '|' expr
        | '!' expr
        | '(' expr ')'</screen>
		</para>

    <para>
    Each expression is evaluated to 1 (TRUE) or 0 (FALSE). Only those hosts
    for which the requirement expression is evaluated to TRUE will be
    considered to execute the job.
    </para>
    <para>
      Logical operators are as expected ( less '&lt;', greater '>', '&' AND,
      '|' OR, '!' NOT), '=' means equals with integers. When you use '='
      operator with strings, it performs a shell wildcard pattern matching.
    </para>
    <para>
    Examples:
    <screen>
REQUIREMENTS = LRMS_NAME = "*pbs*"; # Only use pbs like jobmanagers
REQUIREMENTS = HOSTNAME = "*.es"; #Only hosts in Spain
REQUIREMENTS = HOSTNAME = "hydrus.dacya.ucm.es"; #Only use hydrus.dacya.ucm.es</screen>
    </para>
    </sect2>

    <sect2>
    <title>Rank expression syntax</title>

    <para>
    The syntax of the rank expressions is defined as:
    <screen>
stmt::= expr';'
expr::= VARIABLE
        | INTEGER
        | expr '+' expr
        | expr '-' expr
        | expr '*' expr
        | expr '/' expr
        | '-' expr
        | '(' expr ')'</screen>
    </para>

    <para>
    Rank expressions are evaluated using each host information. '+', '-', '*',
    '/' and '-' are arithmetic operators, so only integer values should be used
    in rank expressions.
    </para>

    <note>
    <para>
    Remember that the <parameter>nice</parameter> parameter for the information
    manager is added to the computed rank value.
    </para>
    </note>
    </sect2>

    <sect2>
    <title>Requirement and rank variables</title>

		<para>
    To set the <emphasis>REQUIREMENTS</emphasis> and <emphasis>RANK</emphasis>
    parameter values the following extended set of variables, provided by the
    Information Manager, can be used:
    </para>

    <table frame='all'>
	  <title>Variables that can be used to define the job <emphasis>REQUIREMENTS</emphasis> and <emphasis>RANK</emphasis>.</title>
		  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
			<colspec colname='c1'>
			<colspec colname='c2'>
    	<tbody>
        <row>
		    <entry>HOSTNAME</entry>
			  <entry>FQDN (Fully Qualified Domain Name) of the execution host
        (e.g. "hydrus.dacya.ucm.es")</entry>
				</row>

        <row>
				<entry>ARCH</entry>
				<entry>Architecture of the execution host (e.g. "i686", "alpha")</entry>
    		</row>

        <row>
		    <entry>OS_NAME</entry>
			  <entry>Operating System name of the execution host (e.g. "Linux", "SL")</entry>
				</row>

        <row>
				<entry>OS_VERSION</entry>
				<entry>Operating System version of the execution host (e.g. "2.6.9-1.66", "3")</entry>
    		</row>

        <row>
		    <entry>CPU_MODEL</entry>
			  <entry>CPU model of the execution host (e.g. "Intel(R) Pentium(R) 4 CPU 2", "PIV")</entry>
				</row>

        <row>
				<entry>CPU_MHZ</entry>
				<entry>CPU speed in MHz of the execution host</entry>
    		</row>

        <row>
		    <entry>CPU_FREE</entry>
			  <entry>Percentage of free CPU of the execution host</entry>
				</row>

        <row>
				<entry>CPU_SMP</entry>
				<entry>CPU SMP size of the execution host</entry>
    		</row>

        <row>
		    <entry>NODECOUNT</entry>
			  <entry>Total number of nodes of the execution host</entry>
				</row>

        <row>
				<entry>SIZE_MEM_MB</entry>
				<entry>Total memory size in MB of the execution host</entry>
    		</row>

        <row>
		    <entry>FREE_MEM_MB</entry>
			  <entry>Free memory in MB of the execution hosts</entry>
				</row>

        <row>
    		<entry>SIZE_DISK_MB</entry>
	    	<entry>Total disk space in MB of the execution hosts</entry>
		    </row>

        <row>
				<entry>FREE_DISK_MB</entry>
				<entry>Free disk space in MB of the execution hosts</entry>
				</row>

        <row>
	    	<entry>LRMS_NAME</entry>
		    <entry>Name of local DRM system (job manager) for execution, usually
        not fork (e.g. "jobmanager-pbs", "PBS", "jobmanager-sge", "SGE")</entry>
			  </row>

        <row>
				<entry>LRMS_TYPE</entry>
				<entry>Type of local DRM system for execution (e.g. "pbs", "sge")</entry>
    		</row>

        <row>
		    <entry>QUEUE_NAME</entry>
			  <entry>Name of the queue (e.g. "default", "short", "dteam")</entry>
				</row>

        <row>
        <entry>QUEUE_NODECOUNT</entry>
        <entry>Total node count of the queue</entry>
		    </row>

        <row>
        <entry>QUEUE_FREENODECOUNT</entry>
        <entry>Free node count of the queue</entry>
				</row>

        <row>
	    	<entry>QUEUE_MAXTIME</entry>
		    <entry>Maximum wall time of jobs in the queue</entry>
			  </row>

        <row>
				<entry>QUEUE_MAXCPUTIME</entry>
				<entry>Maximum CPU time of jobs in the queue</entry>
    		</row>

        <row>
		    <entry>QUEUE_MAXCOUNT</entry>
        <entry>Maximum count of jobs that can be submitted in one request to
        the queue</entry>
				</row>

        <row>
				<entry>QUEUE_MAXRUNNINGJOBS</entry>
        <entry>Maximum number of running jobs in the queue</entry>
	    	</row>

        <row>
			  <entry>QUEUE_MAXJOBSINQUEUE</entry>
        <entry>Maximum number of queued jobs in the queue</entry>
				</row>

        <row>
	    	<entry>QUEUE_DISPATCHTYPE</entry>
        <entry>Dispatch type of the queue (e.g. "batch", "inmediate")</entry>
			  </row>

        <row>
    		<entry>QUEUE_PRIORITY</entry>
        <entry>Priority of the queue</entry>
		    </row>

        <row>
        <entry>QUEUE_STATUS</entry>
        <entry>Status of the queue  (e.g. "active", "production")</entry>
		    </row>
      </tbody>
	   	</tgroup>
    </table>
    </sect2>
	</sect1>

	<sect1>
	<title>Job environment</title>

  <para>
  Job environment variables can be easily set with the <parameter>ENVIRONMENT
  </parameter> parameter of the Job Template. These environment variables are
  parsed, so you can use the GridWay variables defined in
  <xref linkend='VarSub'>, to set the job environment.
  </para>

  <note>
  <para>
  The variables defined in the ENVIRONMENT are "sourced" in a bash shell. In
  this way you can take advantage of the bash substitution capabilities and
  built-in functions. For example:
	</para>
  <screen>
ENVIRONMENT = VAR = "`expr ${JOB_ID} + 3`" # will set VAR to JOB_ID + 3</screen>
  </note>

  <para>
  In addition to those variables set in the <parameter>ENVIRONMENT
  </parameter> parameter, GridWay set the following variables, that can be used
  by your applications:
    <itemizedlist>
        <listitem>
          <para>GW_RESTARTED</para>
        </listitem>
        <listitem>
          <para>GW_EXECUTABLE</para>
        </listitem>
        <listitem>
          <para>GW_HOSTNAME</para>
        </listitem>
        <listitem>
          <para>GW_ARCH</para>
        </listitem>
        <listitem>
          <para>GW_CPU_MHZ</para>
        </listitem>
        <listitem>
          <para>GW_MEM_MB</para>
        </listitem>
        <listitem>
          <para>GW_RESTART_FILES</para>
        </listitem>
        <listitem>
          <para>GW_CPULOAD_THRESHOLD</para>
        </listitem>
        <listitem>
          <para>GW_ARGUMENTS</para>
        </listitem>
        <listitem>
          <para>GW_TASK_ID</para>
        </listitem>
        <listitem>
          <para>GW_CPU_MODEL</para>
        </listitem>
        <listitem>
          <para>GW_ARRAY_ID</para>
        </listitem>
        <listitem>
          <para>GW_TOTAL_TASKS</para>
        </listitem>
        <listitem>
          <para>GW_JOB_ID</para>
        </listitem>
        <listitem>
          <para>GW_OUTPUT_FILES</para>
        </listitem>
        <listitem>
          <para>GW_INPUT_FILES</para>
        </listitem>
        <listitem>
          <para>GW_OS_NAME</para>
        </listitem>
        <listitem>
          <para>GW_USER</para>
        </listitem>
        <listitem>
          <para>GW_DISK_MB</para>
        </listitem>
        <listitem>
          <para>GW_OS_VERSION</para>
        </listitem>
    </itemizedlist>
  </para>
  </sect1>
</chapter>





<chapter>
<title>Job Submission Description Language (JSDL)</title>
  <sect1>
  <title>JSDL overview</title>
  <para>
    GridWay supports Job Submission Description Language (JSDL). This
    specification is a language for describing the job requirements for
    submission to resources. The JSDL language specification is based on XML
    Schema that facilitate the expression of those requirements as a set of XML
    elements. More info at <ulink
    url="http://forge.gridforum.org/sf/projects/jsdl-wg">https://forge.gridforum.org/sf/projects/jsdl-wg
    </ulink>
  </para>
  </sect1>
  <sect1>
  <title>JSDL document structure</title>
  <para>
    The JDSL document structure is as follows:
  </para>
<screen>
&lt;JobDefinition>
|-------&lt;JobDescription>
|---------------&lt;JobIdentification>
|-----------------------&lt;JobName>?
|-----------------------&lt;Description>?
|-----------------------&lt;JobAnnotation>*
|-----------------------&lt;JobProject>*
|-----------------------&lt;xsd:any##other>*
|---------------&lt;/JobIdentification>?
|---------------&lt;Application>
|-----------------------&lt;ApplicationName>?
|-----------------------&lt;ApplicationVersion>?
|-----------------------&lt;Description>?
|-----------------------&lt;xsd:any##other>*
|---------------&lt;/Application>?
|---------------&lt;Resources>?
|-----------------------&lt;CandidateHosts>
|-------------------------------&lt;HostName>+
|-----------------------&lt;/CandidateHosts>?
|-----------------------&lt;FileSystem>
|-------------------------------&lt;Description>?
|-------------------------------&lt;MountPoint>?
|-------------------------------&lt;MountSource>?
|-------------------------------&lt;DiskSpace>?
|-------------------------------&lt;FileSystemType>?
|-------------------------------&lt;xsd:any##other>*
|-----------------------&lt;/FileSystem>*
|-----------------------&lt;ExclusiveExecution>?
|-----------------------&lt;OperatingSystem>?
|-------------------------------&lt;OperatingSystemType>
|---------------------------------------&lt;OperatingSystemName>
|---------------------------------------&lt;xsd:any##other>*
|-------------------------------&lt;/OperatingSystemType>?
|-------------------------------&lt;OperatingSystemVersion>?
|-------------------------------&lt;Description>?
|-------------------------------&lt;xsd:any##other>*
|-----------------------&lt;/OperatingSystem>?
|-----------------------&lt;CPUArchitecture>
|-------------------------------&lt;CPUArchitectureName>
|-------------------------------&lt;xsd:any##other>*
|-----------------------&lt;/CPUArchitecture>?
|-----------------------&lt;IndividualCPUSpeed>?
|-----------------------&lt;IndividualCPUTime>?
|-----------------------&lt;IndividualCPUCount>?
|-----------------------&lt;IndividualNetworkBandwidth>?
|-----------------------&lt;IndividualPhysicalMemory>?
|-----------------------&lt;IndividualVirtualMemory>?
|-----------------------&lt;IndividualDiskSpace>?
|-----------------------&lt;TOTALCPUTime>?
|-----------------------&lt;TOTALCPUCount>?
|-----------------------&lt;TOTALPhysicalMemory>?
|-----------------------&lt;TOTALVirtualMemory>?
|-----------------------&lt;TOTALDiskSpace>?
|-----------------------&lt;TOTALResourceCount>?
|-----------------------&lt;xsd:any##other>*
|---------------&lt;/Resources>?
|---------------&lt;DataStaging>
|-----------------------&lt;FileName>
|-----------------------&lt;FileSystemName>?
|-----------------------&lt;CreationFlag>
|-----------------------&lt;DeleteOnTermination>?
|-----------------------&lt;Source>
|-------------------------------&lt;URI>?
|-------------------------------&lt;xsd:any##other>*
|-----------------------&lt;/Source>?
|-----------------------&lt;Target>
|-------------------------------&lt;URI>?
|-------------------------------&lt;xsd:any##other>*
|-----------------------&lt;/Target>?
|-----------------------&lt;xsd:any##other>*
|---------------&lt;/DataStaging>*
|---------------&lt;xsd:any##other>*
&lt;/JobDefinition>
</screen>
<note>
  <para>
  The symbol <emphasis role="bold">"?"</emphasis> denotes zero or one occurrences,
  <emphasis role="bold">"*"</emphasis> denotes zero or more occurrences and
  <emphasis role="bold">"+"</emphasis> denotes one or more occurrences.
  </para>
</note>
  <sect2>
    <title>JSDL POSIX application</title>
    <para>
      This schema defines the JSDL specification for describing an application executed on a POSIX
      compliance system. Due to GridWay Job Template specification, this schema MUST be included in the
      JSDL file. The JSDL POSIX Application Schema is as follow:
    </para>
<screen>
&lt;POSIXApplication name="xsd:NCName"?>
|-------&lt;Executable>?
|-------&lt;Argument>*
|-------&lt;Input>?
|-------&lt;Output>?
|-------&lt;Error>?
|-------&lt;WorkingDirectory>?
|-------&lt;Environment>*
|-------&lt;WallTimeLimit>?
|-------&lt;FileSizeLimit>?
|-------&lt;CoreDumpLimit>?
|-------&lt;DataSegmentLimit>?
|-------&lt;LockedMemoryLimit>?
|-------&lt;MemoryLimit>?
|-------&lt;OpenDescriptorsLimit>?
|-------&lt;PipeSizeLimit>?
|-------&lt;StackSizeLimit>?
|-------&lt;CPUTimeLimit>?
|-------&lt;ProcessCountLimit>?
|-------&lt;VirtualMemoryLimit>?
|-------&lt;ThreadCountLimit>?
|-------&lt;UserNamet>?
|-------&lt;GroupName>?
&lt;/POSIXApplication name="xsd:NCName"?>
</screen>
  <para>
    More details at
    <ulink url="http://forge.gridforum.org/sf/projects/jsdl-wg">https://forge.gridforum.org/sf/projects/jsdl-wg
    </ulink>
  </para>
  </sect2>
  </sect1>
  <sect1>
  <title>Job Submission Description Language versus GridWay Job Template</title>
  <para>
      Next table compares JSDL and GridWay Job Template schema, and the JSDL elements support by the current GridWay version.

  <table id='TableJSDLvsGWJT' frame='all'> <title>JSDL vs GWJT</title>
    <tgroup cols='3' align='left' colsep='1' rowsep='1'>

    <colspec colname='c1' colwidth='5cm'>
    <colspec colname='c2' colwidth='4cm'>
    <colspec colname='c3' colwidth='3cm'>
    <!--<colspec colname='c4' colwidth='6cm'>-->

        <tbody>
          <row>
        <entry><emphasis role="bold">JSDL Element</emphasis></entry>
        <entry><emphasis role="bold">GWJT Attribute</emphasis></entry>
        <entry><emphasis role="bold">Adoption</emphasis></entry>
        <!--<entry><emphasis role="bold">Comments</emphasis></entry>-->
    </row>
    <row>
        <entry>JobDefinition</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>JobDescription</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>JobIdentification</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>JobName</entry>
        <entry>NAME</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>JobAnnotation</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>JobProject</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Application</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>ApplicationName</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>ApplicationVersion</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Description</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Resources</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>CandidateHosts</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>HostName</entry>
        <entry>HOSTNAME</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>FileSystem</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>MountPoint</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>MountSource</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>DiskSpace</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>FileSystemType</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>ExclusiveExecution</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>OperatingSystem</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>OperatingSystemType</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>OperatingSystemName</entry>
        <entry>OS_NAME</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>OperatingSystemVersion</entry>
        <entry>OS_VERSION</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>CPUArchitecture</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>CPUArchitectureName</entry>
        <entry>ARCH</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>IndividualCPUSpeed</entry>
        <entry>CPU_MHZ</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>IndividualCPUTime</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>IndividualCPUCount</entry>
        <entry>NODECOUNT</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>IndividualNetworkBandwidth</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>IndividualPhysicalMemory</entry>
        <entry>MEM_MB</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>IndividualVirtualMemory</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>IndividualDiskSpace</entry>
        <entry>SIZE_DISK_MB</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>TOTALCPUTime</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>TOTALCPUCount</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>TOTALPhysicalMemory</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>TOTALVirtualMemory</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>TOTALDiskSpace</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>TOTALResourceCount</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>DataStaging</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>FileName</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>FileSystemName</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>CreationFlag</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>DeleteOnTermination</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Source</entry>
        <entry>INPUT_FILES</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Target</entry>
        <entry>OUTPUT_FILES</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>URI</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>POSIXApplication</entry>
        <entry>-</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Executable</entry>
        <entry>EXECUTABLE</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Argument</entry>
        <entry>ARGUMENTS</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Input</entry>
        <entry>STDIN_FILE</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Output</entry>
        <entry>STDOUT_FILE</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Error</entry>
        <entry>STDERR_FILE</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>WorkingDirectory</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>Environment</entry>
        <entry>ENVIRONMENT</entry>
        <entry>Supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>WallTimeLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>FileSizeLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>CoreDumpLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>DataSegmentLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>LockedMemoryLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>MemoryLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>OpenDescriptorsLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>PipeSizeLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>StackSizeLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>CPUTimeLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>ProcessCountLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>VirtualMemoryLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>ThreadCountLimit</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>UserName</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    <row>
        <entry>GroupName</entry>
        <entry>-</entry>
        <entry>Not supported</entry>
        <!--<entry>-</entry>-->
    </row>
    </tbody>
    </tgroup>
  </table>
    </para>
  </sect1>

  <sect1>
    <title>A simple example</title>
    <para>
      This example shows the representation of a simple job in JSDL format and the translator of this
      example in Gridway Job Template format.
    </para>
    <sect2>
    <title>JSDL file</title>
    <para>
<screen width='80'>
<?xml version="1.0" encoding="UTF-8"?>

<!--*
    * Basic schema of GridWay job
    *
    *-->

&lt;jsdl:JobDefinition xmlns="http://www.example.org/"
    xmlns:jsdl="http://schemas.ggf.org/jsdl/2005/11/jsdl"
    xmlns:jsdl-posix="http://schemas.ggf.org/jsdl/2005/11/jsdl-posix"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  &lt;jsdl:JobDescription>
    &lt;jsdl:JobIdentification>
      &lt;jsdl:JobName>Simple Application GW Template vs JSDL&lt;/jsdl:JobName>
      &lt;jsdl:Description> This is a simple example to describe the main
             differences between GW Template and the JSDL schema.
      &lt;/jsdl:Description>
    &lt;/jsdl:JobIdentification>
    &lt;jsdl:Application>
      &lt;jsdl:ApplicationName>ls&lt;/jsdl:ApplicationName>
      &lt;jsdl-posix:POSIXApplication>
        &lt;jsdl-posix:Executable>/bin/ls&lt;/jsdl-posix:Executable>
        &lt;jsdl-posix:Argument>-la file.txt&lt;/jsdl-posix:Argument>
        &lt;jsdl-posix:Environment name="LD_LIBRARY_PATH">/usr/local/lib&lt;/jsdl-posix:Environment>
        &lt;jsdl-posix:Input>/dev/null&lt;/jsdl-posix:Input>
        &lt;jsdl-posix:Output>stdout.${JOB_ID}&lt;/jsdl-posix:Output>
        &lt;jsdl-posix:Error>stderr.${JOB_ID}&lt;/jsdl-posix:Error>
      &lt;/jsdl-posix:POSIXApplication>
    &lt;/jsdl:Application>
    &lt;jsdl:Resources>
      &lt;jsdl:CandidateHost>
        &lt;jsdl:HostName>*.dacya.ucm.es&lt;/jsdl:HostName>
      &lt;/jsdl:CandidateHost>
      &lt;jsdl:CPUArchitecture>
        &lt;jsdl:CPUArchitectureName>x86_32&lt;/jsdl:CPUArchitectureName>
      &lt;/jsdl:CPUArchitecture>
    &lt;/jsdl:Resources>
    &lt;jsdl:DataStaging>
      &lt;jsdl:FileName>file.txt&lt;/jsdl:FileName>
      &lt;jsdl:CreationFlag>overwrite&lt;/jsdl:CreationFlag>
      &lt;jsdl:DeleteOnTermination>true&lt;/jsdl:DeleteOnTermination>
      &lt;jsdl:Source>
        &lt;jsdl:URI>gsiftp://hydrus.dacya.ucm.es/home/jose/file1.txt&lt;/jsdl:URI>
      &lt;/jsdl:Source>
    &lt;/jsdl:DataStaging>
    &lt;jsdl:DataStaging>
      &lt;jsdl:FileName>stdout.${JOB_ID}&lt;/jsdl:FileName>
      &lt;jsdl:CreationFlag>overwrite&lt;/jsdl:CreationFlag>
      &lt;jsdl:DeleteOnTermination>true&lt;/jsdl:DeleteOnTermination>
      &lt;jsdl:Target>
        &lt;jsdl:URI>gsiftp://hydrus.dacya.ucm.es/home/jose/stdout.${JOB_ID}&lt;/jsdl:URI>
      &lt;/jsdl:Target>
    &lt;/jsdl:DataStaging>
    &lt;jsdl:DataStaging>
      &lt;jsdl:FileName>stderr.${JOB_ID}&lt;/jsdl:FileName>
      &lt;jsdl:CreationFlag>overwrite&lt;/jsdl:CreationFlag>
      &lt;jsdl:DeleteOnTermination>true&lt;/jsdl:DeleteOnTermination>
      &lt;jsdl:Target>
        &lt;jsdl:URI>gsiftp://hydrus.dacya.ucm.es/home/jose/stderr.${JOB_ID}&lt;/jsdl:URI>
      &lt;/jsdl:Target>
    &lt;/jsdl:DataStaging>
  &lt;/jsdl:JobDescription>
&lt;/jsdl:JobDefinition>
</screen>
</para>
</sect2>
    <sect2>
    <title>GridWay Job Template file</title>
    <para>
<screen>
#This file was automatically generated by the JSDL2GWJT parser
EXECUTABLE=/bin/ls
ARGUMENTS=-la file.txt
STDIN_FILE=/dev/null
STDOUT_FILE=stdout.${JOB_ID}
STDERR_FILE=stderr.${JOB_ID}
ENVIRONMENT=LD_LIBRARY_PATH=/usr/local/lib
REQUIREMENTS=HOSTNAME="*.dacya.ucm.es" & ARCH="x86_32"
INPUT_FILES=file.txt</screen>
</para>
    </sect2>
  </sect1>
</chapter>





<chapter>
<title>Usage scenarios</title>
  <sect1>
	<title>Single jobs: Submitting and monitoring the simplest job</title>

  <para>
    GWD should be configured and running. Check the <emphasis>Installation and
    Configuration Guide</emphasis> and <xref linkend='UserEnvConf'> to do
    that. Do not forget to create a proxy with
    <command>grid-proxy-init</command>
  </para>

  <para>
  To submit a job, you will need a Job Template. The most simple Job Template
  in GridWay could be:
  <screen>
EXECUTABLE=/bin/ls</screen>
  </para>
  <para>
  Save it as file <filename>jt</filename> in directory
  <filename>example</filename>.
  </para>

  <para>
  Use the <command>gwsubmit</command> command to submit the job:
  <screen>
$ gwsubmit -t example/jt</screen>
	</para>

  <para>
  Let see how many resources are available in our Grid, with
  <command>gwhost</command>:
  </para>

  <screen width='80'>
HID PRIO OS              ARCH   MHZ %CPU MEM(F/T)     DISK(F/T)  N(U/F/T) LRMS  HOSTNAME
0   1    Linux2.6.17-2-6 x86   3215  100 923/2027 105003/118812     0/1/2 Fork  cygnus.dacya.ucm.es
1   1    Linux2.6.17-2-6 x86   3216  189 384/2027 105129/118812     0/2/2 Fork  draco.dacya.ucm.es
2   1    Linux2.6.18-3-a x86_6 2211  100 749/1003   76616/77844     0/2/2 SGE   aquila.dacya.ucm.es
3   1                             0    0      0/0           0/0     0/0/0       hydrus.dacya.ucm.es
4   1    Linux2.6.18-3-a x86_6 2009   74  319/878 120173/160796     0/1/1 Fork  orion.dacya.ucm.es
5   1    Linux2.6.16.13- x86   3200  100  224/256       114/312     0/6/6 SGE   ursa.dacya.ucm.es</screen>

  <para>
  Note that hydrus is down in this example, so no information is received at all
  and of course, this host won't be considered in future scheduling decisions.
  If you want to retrieve more information about a single resource, issue the
  <command>gwhost</command> command followed by the host identification (HID):
  </para>		  

<screen width='80'>
$ gwhost 0
HID PRIO OS              ARCH   MHZ %CPU MEM(F/T)     DISK(F/T)  N(U/F/T) LRMS  HOSTNAME
5   1    Linux2.6.16.13- x86   3200  100  224/256       114/312     0/6/6 SGE   ursa.dacya.ucm.es

QUEUENAME            SL(F/T) WALLT CPUT  COUNT MAXR  MAXQ  STATUS   DISPATCH   PRIORITY
all.q                6/6     0     0     0     6     0     enabled  NULL       0</screen>

  <para>
  You can also check the resources that match your requirements with <command>gwhost -m 0</command>.
  </para>

  <screen>
HID QNAME      RANK  PRIO  SLOTS HOSTNAME
0   default    0     1     2     cygnus.dacya.ucm.es
1   default    0     1     0     draco.dacya.ucm.es
2   all.q      0     1     2     aquila.dacya.ucm.es
4   default    0     1     1     orion.dacya.ucm.es
5   all.q      0     1     6     ursa.dacya.ucm.es</screen>

  <para>
  Now, you can check the evolution of the job with the <command>gwps</command>
  command.
  <screen width='80'>
USER         JID DM   EM   RWS START    END      EXEC    XFER    EXIT NAME  HOST
jlvazquez    0   pend ---- 000 10:42:09 --:--:-- 0:00:00 0:00:00 --   jt    --

USER         JID DM   EM   RWS START    END      EXEC    XFER    EXIT NAME  HOST
jlvazquez    0   prol ---- 000 10:42:09 --:--:-- 0:00:00 0:00:01 --   jt    cygnus.dacya.ucm.es/Fork

USER         JID DM   EM   RWS START    END      EXEC    XFER    EXIT NAME  HOST
jlvazquez    0   wrap ---- 000 10:42:09 --:--:-- 0:00:27 0:00:04 --   jt    cygnus.dacya.ucm.es/Fork

USER         JID DM   EM   RWS START    END      EXEC    XFER    EXIT NAME  HOST
jlvazquez    0   wrap pend 000 10:42:09 --:--:-- 0:00:27 0:00:04 --   jt    cygnus.dacya.ucm.es/Fork

USER         JID DM   EM   RWS START    END      EXEC    XFER    EXIT NAME  HOST
jlvazquez    0   wrap actv 000 10:42:09 --:--:-- 0:00:27 0:00:04 --   jt    cygnus.dacya.ucm.es/Fork

USER         JID DM   EM   RWS START    END      EXEC    XFER    EXIT NAME  HOST
jlvazquez    0   epil ---- 000 10:42:09 --:--:-- 0:00:31 0:00:05 --   jt    cygnus.dacya.ucm.es/Fork

USER         JID DM   EM   RWS START    END      EXEC    XFER    EXIT NAME  HOST
jlvazquez    0   done ---- 000 10:42:09 10:43:01 0:00:31 0:00:08 0    jt    cygnus.dacya.ucm.es/Fork</screen>
  </para>

  <para>
  At the beginning, the job is in <emphasis>pending</emphasis> state and not
  allocated to any resource. Then, the job is allocated to
  cygnus.dacya.ucm.es/Fork and begins the <emphasis>prolog</emphasis> stage.
  </para>

  <note>
  <para>
  You can use option <option>-c &lt;delay></option> to see a continuous
  output of the <command>gwps</command> command.
  </para>
  </note>

  <para>
  You can see the job history with the <command>gwhistory</command> command:
  <screen width='80'>
$ gwhistory 0
HID START    END      PROLOG  WRAPPER EPILOG  MIGR    REASON QUEUE    HOST
0   10:42:22 10:43:01 0:00:04 0:00:31 0:00:04 0:00:00 ----   default  cygnus.dacya.ucm.es/Fork</screen>
  </para>

  <para>
  Now it's time to retrieve the results. As you specified by default, the
  results of the execution of this job will be in the same folder, in a text
  file called sdtout_file.$JOB_ID.
  <screen>
$ ls -lt example/
total 8
-rw-r--r-- 1 jlvazquez staff  0 2007-02-20 10:42 stderr.0
-rw-r--r-- 1 jlvazquez staff 72 2007-02-20 10:42 stdout.0
-rw-r--r-- 1 jlvazquez staff 19 2007-02-20 10:33 jt
$ cat example/stdout.0
job.env
stderr.execution
stderr.wrapper
stdout.execution
stdout.wrapper</screen>
  </para>

  <para>
  Done! You have done your first execution with GridWay!
  </para>
  </sect1>

  <sect1>
	<title>Array jobs: Calculating the &pi; number</title>

    <sect2>
		<title>Defining the problem</title>

    <para>
    This is a well known exercise. For our purposes, we will calculate the
    integral of the following function:
      <informalfigure>
        <graphic align="center" fileref="../images/pi1.jpg">
      </informalfigure>
    </para>

    <para>
    Being f(x) = 4/(1+x2). So, &pi; will be the integral of f(x) in the
    interval [0,1].
   	</para>

    <para>
    In order to calculate the whole integral, it's interesting to divide the
    function in several sections and compute them separately:
    <informalfigure>
      <graphic align="center" fileref="../images/pi2.jpg">
      </informalfigure>
    </para>

    <para>
    As you can see, the more sections you make, the more exact &pi; will be:
    <informalfigure>
      <graphic align="center" fileref="../images/pi3.jpg">
    </informalfigure>
    </para>

    <para>
    So, you have a Grid with some nodes, you have GridWay... Why don't use them
    to calculate the &pi; number by giving all the nodes a section to compute
    with only one command?
    </para>

    <note>
    <para>
    You will find all the files needed to perform this example in the
    <filename>$GW_LOCATION/examples/pi</filename> directory.
    </para>
    </note>
		</sect2>

		<sect2>
		<title>The coding part</title>

    <para>
    For this example, we have chosen the C Programming Language. Create a text
    file called <filename>pi.c</filename> and copy inside the following lines:
    </para>

    <programlisting>
#include &lt;stdio.h>
#include &lt;string.h>

int main (int argc, char** args)
{
  int task_id;
  int total_tasks;
  long long int n;
  long long int i;

  double l_sum, x, h;

  task_id = atoi(args[1]);
  total_tasks = atoi(args[2]);
  n = atoll(args[3]);

  fprintf(stderr, "task_id=%d total_tasks=%d n=%lld\n", task_id, total_tasks, n);

  h = 1.0/n;

  l_sum = 0.0;

  for (i = task_id; i < n; i += total_tasks)
  {
    x = (i + 0.5)*h;
    l_sum += 4.0/(1.0 + x*x);
  }

  l_sum *= h;

  printf("%0.12g\n", l_sum);

  return 0;
}
  </programlisting>

    <para>
    Now it's time to compile it:
    <screen>$ gcc -O3 pi.c -o pi</screen>
    </para>

    <para>
    after this, you should have an executable called <command>pi</command>. This
    command receives three parameters:
    <itemizedlist>
      <listitem>
        <para>
          Task identifier: The identifier of the current task.
        </para>
      </listitem>
      <listitem>
        <para>
          Total tasks: The number of tasks the computation should be divided
          into.
        </para>
      </listitem>
      <listitem>
        <para>
          Number of intervals: The number of intervals over which the integral
          is being evaluated.
        </para>
      </listitem>
    </itemizedlist>
  </para>
  </sect2>

  <sect2>
	<title>Defining the job</title>

  <para>
  For making GridWay work with your program, you must create a Job Template. In
  this case, we will call it <filename>pi.jt</filename>. Copy the following
  lines inside:
  <screen>
EXECUTABLE  = pi
ARGUMENTS   = ${TASK_ID} ${TOTAL_TASKS} 100000
STDOUT_FILE = stdout_file.${TASK_ID}
STDERR_FILE = stderr_file.${TASK_ID}
RANK        = CPU_MHZ</screen>
  </para>
  </sect2>

  <sect2>
	<title>Submitting the jobs</title>

    <para>
    This time, we will submit an array of jobs. This is done by issuing the
    following command:
    <screen>
$ gwsubmit -v -t pi.jt -n 4
ARRAY ID: 0

TASK JOB
0    0
1    1
2    2
3    3</screen>
    </para>

    <para>
    In order to wait for the jobs to complete, you can use the
    <command>gwwait</command> command.
    </para>

    <para>
    The argument passed to <command>gwwait</command> is the array identifier
    given by <command>gwsubmit</command> when executed with the
    <option>-v</option> option. It could be also obtained through
    <command>gwps</command>
    </para>

    <para>
    This command will block and return when all jobs have been executed:
    <screen>
$ gwwait -v -A 0
0   : 0
1   : 0
2   : 0
3   : 0</screen>
     This command, when issued with option <option>-v</option> shows the exit
     codes for each job in the array (usually, 0 means success).
    </para>
    </sect2>

    <sect2>
		<title>Result post-processing</title>

    <para>
    The execution of these jobs has returned some output files with the result
    of each execution:
    <screen>
stdout_file.0
stdout_file.1
stdout_file.2
stdout_file.3</screen>
    </para>

    <para>
    Now, we will need something to sum the results inside each file. For this,
    you can use an <command>awk</command> script like the following:
<screen width='80'>
$ awk 'BEGIN {sum=0} {sum+=$1} END {printf "Pi is %0.12g\n", sum}' stdout_file.*
Pi is 3.1415926536</screen>
    </para>

    <para>
    Well, not much precision, right? You could try it again, but this time with
    a much higher number of intervals (e.g. 10,000,000,000). Would you increment
    also the number of tasks? Which would be the best compromise?
    </para>

    <para>
    Do you imagine how easy would be to implement these steps in a shell script
    in order to perform them unattendedly? Here you are the prove:
    <programlisting>
#!/bin/sh

AID=`gwsubmit -v -t pi.jt -n 4 | head -1 | awk '{print $3}'`

if [ $? -ne 0 ]
then
    echo "Submission failed!"
    exit 1
fi

gwwait -v -A $AID

if [ $? -eq 0 ]
then
    awk 'BEGIN {sum=0} {sum+=$1} END {printf "Pi is %0.12g\n", sum}' stdout_file.*
else
    echo "Some tasks failed!"
fi
    </programlisting>
    </para>
    </sect2>
  </sect1>

  <sect1>
  <title>MPI jobs: Calculating the &pi; number again</title>

  <para>
  When applications show fine-grain parallelism, with small computation to
  communication ratio, and thus need lower latencies, MPI (Message Passing
  Interface) jobs give a better choice.
  </para>

  <para>
  Following the &pi; example, we will now perform its computation using MPI in a
  single job. Notice that MPI jobs can also be part of an array or complex job.
  </para>

  <note>
  <para>
  You will find all the files needed to perform this example in the
  <filename>$GW_LOCATION/examples/mpi</filename> directory.
  </para>
  </note>

  <para>
  Create a text file called <filename>mpi.c</filename> and copy inside the
  following lines:
  </para>

  <programlisting>
#include "mpi.h"
#include &lt;stdio.h>
#include &lt;math.h>

int main( int argc, char *argv[])
{
    int done = 0, n, myid, numprocs, i;
    double PI25DT = 3.141592653589793238462643;
    double mypi, pi, h, sum, x;
    double startwtime = 0.0, endwtime;
    int  namelen;
    char processor_name[MPI_MAX_PROCESSOR_NAME];

    MPI_Init(&amp;argc,&amp;argv);
    MPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);
    MPI_Comm_rank(MPI_COMM_WORLD,&amp;myid);
    MPI_Get_processor_name(processor_name,&amp;namelen);

    printf("Process %d on %s\n", myid, processor_name);

    n = 100000000;

    startwtime = MPI_Wtime();

    h   = 1.0 / (double) n;
    sum = 0.0;
    for (i = myid + 1; i <= n; i += numprocs)
    {
        x = h * ((double)i - 0.5);
        sum += 4.0 / (1.0 + x*x);
    }
    mypi = h * sum;

    MPI_Reduce(&amp;mypi, &amp;pi, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);

    if (myid == 0)
    {
        printf("pi is approximately %.16f, Error is %.16f\n",
               pi, fabs(pi - PI25DT));
        endwtime = MPI_Wtime();
        printf("wall clock time = %f\n", endwtime-startwtime);
    }

    MPI_Finalize();

    return 0;
}
  </programlisting>

  <note>
  <para>
  For more information about MPI, see http://www.mcs.anl.gov/mpi.
  </para>
  </note>

  <para>
  Notice that the above program already performs postprocessing in a single
  operand reduction operation MPI_Reduce which sums the partial results
  obtained by each processor.
  </para>

  <para>
  Now it's time to compile it. Notice that you will need a compiler with MPI
  support like <command>mpicc</command>:
  <screen>$ mpicc -O3 mpi.c -o mpi</screen>
  </para>

  <para>
  Now you must create a Job Template. In this case, we will call it
  <filename>mpi.jt</filename>:
  <screen>
EXECUTABLE   = mpi

STDOUT_FILE   = stdout.${JOB_ID}
STDERR_FILE   = stderr.${JOB_ID}

RANK          = CPU_MHZ

TYPE          = "mpi"
NP            = 2
</screen>
  </para>

  </sect1>

  <sect1>
  <title>Workflows</title>

  <para>
  The powerful commands provided by GridWay to submit, control and synchronize
  jobs allow us to programmatically define complex jobs or workflows, where some
  jobs need data generated by other jobs. GridWay allows job submission to be
  dependent on the completion of other jobs. This new functionality provides
  support for the execution of workflows.
  </para>

  <para>
  GridWay allows scientists and engineers to express their computational
  problems by using workflows. The capture of the job exit code allows users to
  define workflows, where each task depends on the output and exit code from the
  previous task. They may even involve branching, looping and spawning of
  subtasks, allowing the exploitation of the parallelism on the workflow of
  certain type of applications. The bash script flow control structures and the
  GridWay commands allow the development of workflows with the following
  functionality:
  <itemizedlist>

    <listitem>
    <para>
    Sequence, parallelism, branching and looping structures
    </para>
    </listitem>

    <listitem>
    <para>
    The workflow can be described in an abstract form without referring to
    specific resources for task execution
    </para>
    </listitem>

    <listitem>
    <para>
    Quality of service constraints and fault tolerance are defined at task level
    </para>
    </listitem>
  </itemizedlist>
  </para>

  <para>
  Job dependencies can be specified at submission by using the
  <command>-d</command> option of the <command>gwsubmit</command> command. A Job
  with dependencies will be submitted in the hold state, and once all the jobs
  on which it depends have successfully finished, it will be released. You can
  also release this job by hand with the <command>gwkill</command>.
  </para>

  <sect2>
  <title>A sample of DAG workflow</title>

  <para>
  A DAG-based workflow consists of a temporal relationship between tasks, where
  the input, output or execution of one ore more tasks depends on one or more
  other tasks. For this example we have chosen a simple workflow.
  </para>

  <figure>
    <title>Workflow example.</title>
    <graphic align="center" fileref="../images/gw_workflow.jpg">
  </figure>

  <para>
  In this example, job A generates a random number, jobs B and C add 1 to that
  number and, finally job D adds the result of these jobs. This is the final
  result is two times the number generated by A, plus two. In our case, the
  numbers are passed  between jobs using the standard output files.
  </para>

  <para>
  Job Template for job A (<filename>A.jt</filename>):
    <screen>
EXECUTABLE=/bin/echo
ARGUMENTS="$RANDOM"
STDOUT_FILE=out.A</screen>
  </para>

  <para>
  Job Template for jobs B and C (<filename>B.jt</filename> and
  <filename>C.jt</filename>):
  <screen>
EXECUTABLE=/usr/bin/expr
ARGUMENTS="`cat out.A`" + 1
INPUT_FILES=out.A
STDOUT_FILE=out.B #out.C for job C</screen>
  </para>

  <para>
  Job Template for job D (<filename>D.jt</filename>):
<screen>
EXECUTABLE=/usr/bin/expr
ARGUMENTS="`cat out.B`" + "`cat out.C`"
INPUT_FILES=out.B, out.C
STDOUT_FILE=out.workflow</screen>
  </para>

  <para>
  Once you have set up the previous Job Templates, the workflow can be easily
  submitted with the following commands:
  <screen>
$ gwsubmit -v -t A.jt
JOB ID: 5

$ gwsubmit -v -t B.jt -d "5"
JOB ID: 6

$ gwsubmit -v -t C.jt -d "5"
JOB ID: 7

$ gwsubmit -t C.jt -d "6 7"</screen>
  </para>

  <note>
  <para>
  In the previous example, jobs B and C can be submitted as an array
  job using just one template with output, <computeroutput>OUTPUT_FILES =
  out.${TASK_ID}</computeroutput>. Therefore, input of job D will be <computeroutput>
  INPUT_FILES = out.0, out.1</computeroutput>.
  </para>
  </note>

  <para>
  The above steps can be easily implemented in a shell script.
  <programlisting>
#!/bin/sh

A_ID=`gwsubmit -v -t A.jt | cut -f2 -d':' | cut -f2 -d' '`
B_ID=`gwsubmit -v -t B.jt -d "$A_ID" | cut -f2 -d':' | cut -f2 -d' '`
C_ID=`gwsubmit -v -t C.jt -d "$A_ID" | cut -f2 -d':' | cut -f2 -d' '`
D_ID=`gwsubmit -v -t D.jt -d "$B_ID $C_ID"| cut -f2 -d':' | cut -f2 -d' '`

#Sync with last job of the workflow
gwwait $D_ID

echo "Random number `cat out.A`"
echo "Workflow computation `cat out.workflow`"
  </programlisting>
  </para>

  <para>
  Note that when input and output files vary depending on the iteration or job
  id number, you should generate Job Templates dynamically before submitting
  each job. This can be done programmatically by using the DRMAA API, or via
  shell scripting.
  </para>
  </sect2>
  </sect1>
</chapter>

<chapter id='Troubleshooting'>
  <title>Troubleshooting</title>
  <sect1>
  <title>Debugging job execution</title>

  <para>
  GridWay reporting and accounting facilities provide information about overall
  performance and help debug job execution. GWD generates the following files
  under the <filename>$GW_LOCATION/var</filename> directory:
  <itemizedlist>
    <listitem>
    <para>
     <filename>gwd.log</filename>: System level log. You can find log
    information of the activity of the middleware access drivers; and a
    coarse-grain log information about jobs.
    </para>
    </listitem>

    <listitem>
    <para>
    <filename>$JOB_ID/job.log</filename>: Detailed log information for each job,
    it includes details of job state transitions, resource usage and
    performance.
    </para>
    </listitem>

    <listitem>
    <para>
    <filename>$JOB_ID/stdout.wrapper</filename>: Standard output of the wrapper
    executable.
    </para>
    </listitem>

    <listitem>
    <para>
    <filename>$JOB_ID/stderr.wrapper</filename>: Standard error output of the
    wrapper executable. By default, wrapper is executed with shell debugging
    options (<option>-xv</option>) active, so this is usually the best source of
    information in case of failure.
    </para>
    </listitem>
  </itemizedlist>
  </para>
  </sect1>

  <sect1>
  <title>Frequent problems</title>

  <para>
  Currently, many errors are handled silently and are only shown in the
  <filename>job.log</filename> file.
  </para>

  <para>
  Also, there is a number of failures related to the underlying middleware
  (Globus in this case) that could make some jobs fail. It is a good idea to
  perform some basic testing of Globus when some jobs unexpectedly fail
  (see the <emphasis>Installation and Configuration Guide</emphasis> to learn
  how to verify a Globus installation)
  </para>

  <para>
  Use the GridWay lists (see <filename>www.gridway.org/support.php</filename>),
  to submit your problems and they will be eventually appear in this guide.
  </para>
  </sect1>
</chapter>
</book>


