<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"
[

<!ENTITY % myents SYSTEM "../../entities">

%myents;

]>
<section>
<section>
  <title>Benefits for the end user </title>

  <para>
  GridWay, on top of Globus services, enables large-scale, secure and reliable
  sharing of computing resources (clusters, computing farms, servers,
  supercomputers...), managed by different resource management systems (PBS,
  SGE, LSF, Condor...), within a single organization (enterprise grid) or
  scattered across several administrative domains (partner or supply-chain
  grid). GridWay provides the end-user with a working environment and
  functionality similar to those found on local DRM systems, such as SGE, LSF or
  PBS. The end-user is able to submit, monitor and control his jobs by means of
  DRM-like commands (<command>gwsubmit</command>, <command>gwwait</command>,
  <command>gwkill</command>, <command>gwhosts</command>...) or the DRMAA API. 
  </para>

  <para>
	The benefits for the end user are:
  <itemizedlist>
    <listitem>
    <para>
    Reliable and unattended execution of jobs: Transparently to the end user,
    the scheduler is able to manage the different failure situations.
    </para>
    </listitem>

    <listitem>
    <para>
    Efficient execution of jobs: Jobs are executed on the faster available
    resources.
    </para>
    </listitem>

    <listitem>
    <para>
    Broad application scope: GridWay is not bounded to a specific class of
    application generated by a given programming environment and does not
    require application deployment on remote hosts, which extends its
    application range and allows reusing of existing software. GridWay allows
    submission of single, array or complex jobs consisting of task dependencies,
    which may require file transferring and/or database access.
    </para>
    </listitem>

    <listitem>
    <para>
    DRM Command Line Interface: The GridWay command line interface is similar to
    that found on Unix and resource management systems such as PBS or SGE. It
    allows users to submit, kill, migrate, monitor and synchronize jobs.
    Moreover, jobs can be specified in GridWay Job Template format or using the
    JSDL (Job Submission Description Language) OGF standard.
    </para>
    </listitem>

    <listitem>
    <para>
    DRMAA Application Programming Interface: GridWay provides full support for
    DRMAA (OGF standard) to develop distributed applications (C, Java, Perl, Ruby and Python bindings).
    </para>
    </listitem>
  </itemizedlist>
  </para>
  </section>

  <section>
  <title>How GridWay operates</title>

  <para>
  GridWay enables you to treat your jobs as if they were Unix processes. Each
  job is given a numerical identifier, analogous to the PID of a process. This
  value is called the Job identifier, JID for short. If the job belongs to an
  array job, it will also have an array identifier, AID for short. A job index
  within an array is called the task identifier, TID for short.
  </para>

  <para>
  Jobs are submitted using the <command>gwsubmit</command> command. A job is
  described by its template file. Here you can specify the job's executable
  file, its command line arguments, input/output files, standard stream
  redirection as well as other aspects.
  </para>

  <para>
  Jobs can be monitored using the <command>gwps</command> command. You can
  control your jobs at runtime using the <command>gwkill</command> command. You
  can synchronize your jobs using the <command>gwwait</command> command. You can
  find out what resources your job has used with the
  <command>gwhistory</command> command.
  </para>

  <para>
  System monitoring commands allow you to gather information of the GridWay
  system and the Grids you are using. These commands are:
  <command>gwuser</command> to show information about the users using GridWay;
  <command>gwhost</command> to monitor the  available hosts in the testbed; and
  <command>gwacct</command> to print usage (accounting) information per user or
  host.
  </para>

  <note>
  <para>
  Every command has a <option>-h</option> option which shows its usage and
  available options.
  </para>
  </note>
  </section>

  <section>
  <title>Job life-cycle in GridWay</title>

  <para>
  A job can be in one of the following dispatch states (DM state):
  <itemizedlist>
    <listitem>
    <para>
    Pending (<computeroutput>pend</computeroutput>): The job is waiting for a
    resource to run on. The job reaches this state when it is initially
    submitted by the user or when it is restarted after a failure, stop or
    self-migration.
    </para>
    </listitem>

    <listitem>
    <para>
    Hold (<computeroutput>hold</computeroutput>): The owner (or GridWay
    administrator) has held the job. It will not be scheduled until it receives
    a release signal.
    </para>
    </listitem>

    <listitem>
    <para>
    Prolog (<computeroutput>prol</computeroutput>): The job is preparing the
    remote system, by creating the execution directory in the remote host and
    transferring the input and restart (in case of migration) files to it.
    </para>
    </listitem>

    <listitem>
    <para>
    Pre-wrapper (<computeroutput>prew</computeroutput>): The job is making some
    advanced preparation tasks in the remote resource, like getting some data
    from a service, obtaining software licenses, etc.
    </para>
    </listitem>

    <listitem>
    <para>
    Wrapper (<computeroutput>wrap</computeroutput>): The job is executing the
    Wrapper, which in turns executes the actual application. It also starts a
    self-monitoring program if specified. This monitor, watches the raw
    performance (CPU usage) obtained by the application.
    </para>
    </listitem>

    <listitem>
    <para>
    Epilog (<computeroutput>epil</computeroutput>): The job is finalizing. In
    this phase it transfers the output and restart (in case of failure, stop or
    self-migration) files and cleaning up the remote system directory.
    </para>
    </listitem>

    <listitem>
    <para>
    Migrate (<computeroutput>migr</computeroutput>): The job is migrating from
    one resource to another, by canceling the execution of Wrapper and
    performing finalization tasks in the old resource (like in Epilog state) and
    preparation tasks in the new resource (like in Prolog state).
    </para>
    </listitem>

    <listitem>
    <para>
    Stopped (<computeroutput>stop</computeroutput>): The job is stopped. If
    restart files have been defined in the Job Template, they are transferred
    back to the client, and will be used when the job is resumed.
    </para>
    </listitem>

    <listitem>
    <para>
    Failed (<computeroutput>fail</computeroutput>): The job failed.
    </para>
    </listitem>

    <listitem>
    <para>
    Done (<computeroutput>done</computeroutput>): The job is done and the user
    can check the exit status.
    </para>
    </listitem>
    </itemizedlist>
  </para>

  <figure>
    <title>Simplified state machine of the GridWay Metascheduler.</title>
    <graphic align="center" fileref="user/gw_states.jpg"/>
  </figure>

  <para>
  When a job is in Wrapper dispatch state, it can be in one of the following
  execution states (EM state), which are a subset of the available Globus GRAM
  states:
  <itemizedlist>

    <listitem>
    <para>
    Pending (<computeroutput>pend</computeroutput>): The job has been
    successfully submitted to the local DRM system and it is waiting for the
    local DRM system to execute it.
    </para>
    </listitem>

    <listitem>
    <para>
    Suspended (<computeroutput>susp</computeroutput>): The job has been
    suspended by the local DRM system.
    </para>
    </listitem>

    <listitem>
    <para>
    Active (<computeroutput>actv</computeroutput>): The job is being executed by
    the local DRM system
    </para>
    </listitem>

    <listitem>
    <para>
    Failed (<computeroutput>fail</computeroutput>): The job failed.
    </para>
    </listitem>

    <listitem>
    <para>
    Done (<computeroutput>done</computeroutput>): The job is done.
    </para>
    </listitem>

  </itemizedlist>
  </para>

  <para>
  Finally, The following flags are associated with a job (RWS flags):
  <itemizedlist>

    <listitem>
    <para>
    Restarted (<computeroutput>R</computeroutput>): Number of times the job was
    restarted or migrated.
    </para>
    </listitem>

    <listitem>
    <para>
    Waiting (<computeroutput>W</computeroutput>): Number of clients waiting for
    this job to end.
    </para>
    </listitem>

    <listitem>
    <para>
    Rescheduled (<computeroutput>S</computeroutput>): 1 if this job is waiting
    to be rescheduled, 0 otherwise.
    </para>
    </listitem>
  </itemizedlist>
  </para>
  </section>

  <section>
  <title>A grid-aware application model</title>

  <para>
  In order to obtain a reasonable degree of both application performance and
  fault tolerance, a job must be able to adapt itself according to the
  availability of the resources and the current performance provided by them.
  Therefore, the classical application model must be extended to achieve
  such functionality.
  </para>

  <para>
  The GridWay system assumes the following application model:
  <itemizedlist>

    <listitem>
    <para>
    <emphasis>Executable</emphasis>: The executable must be compiled for the
    remote host architecture. GridWay provides a straightforward method to
    select the appropriate executable for each host. The variable
    <varname>GW_ARCH</varname>, as provided by the Information MAD, can be used
    to define the executable in the Job Template (for example,
    EXECUTABLE=sim_code.${GW_ARCH})
    </para>
    </listitem>

    <listitem>
    <para>
    <emphasis>Input files</emphasis>: These files are staged to the remote host.
    GridWay provides a flexible way to specify input files and supports
    Parameter Sweep like definitions. Please note that these files may be also
    architecture dependent.
    </para>
    </listitem>

    <listitem>
    <para>
    <emphasis>Output files</emphasis>: These files are generated on the remote
    host and transferred back to the client once the job has finished.
    </para>
    </listitem>

    <listitem>
    <para>
    <emphasis>Standard streams</emphasis>: The standard input (STDIN) file is
    transferred to the remote system previous to job execution. Standard output
    (STDOUT) and standard error (STDERR) streams are also available at the
    client once the job has finished. These files could be extremely useful for
    debugging.
    </para>
    </listitem>

    <listitem>
    <para>
    <emphasis>Restart files</emphasis>: Restart files are highly advisable if
    dynamic scheduling is performed. User-level checkpointing managed by the
    programmer must be implemented because system-level checkpointing is not
    possible among heterogeneous resources.
    </para>
    </listitem>
  </itemizedlist>
  </para>

  <para>
  Migration is commonly implemented by restarting the job on the new candidate
  host. Therefore, the job should generate restart files at regular intervals in
  order to restart execution from a given point. However, for some application
  domains the cost of generating and transferring restart files could be greater
  than the saving in compute time due to checkpointing. Hence, if the
  checkpointing files are not provided the job is restarted from the beginning.
  In order not to reduce the number of candidate hosts where a job can migrate,
  the restart files should be architecture independent.
  </para>
  </section>
</section>
